/**  
 * Create time May 31, 2009 4:33:31 PM  
 */  
package com.yd.image;   
  
import java.awt.Rectangle;   
import java.awt.image.BufferedImage;   
  
import java.io.File;   
import java.io.FileInputStream;   
import java.io.IOException;   
import java.util.Iterator;   
  
import javax.imageio.ImageIO;   
import javax.imageio.ImageReadParam;   
import javax.imageio.ImageReader;   
import javax.imageio.stream.ImageInputStream;   
  
  
/**  
 * <p>Title: CutImage</p>  
 * <p>Description: </p>  
 *  
 *  
 * @version 1.0  
 */  
public class CutImage {   
       
    private static int x_share = 8; //x切片份数   
    private static int y_share = 10; //y切片份数   
    private static String srcpath = "F:/pic/xiaohei.jpg"; //源图片路径名称   
    private static String subpath = "F:/pic/cut/"; //剪切图片存放的目录     
    private int x; //剪切点x坐标   
    private int y; //剪切点y坐标    
    private int width; //剪切点宽度   
    private int height; //剪切点高度   
    private int num;   
  
    public CutImage() { }   
  
    public CutImage(int x, int y, int width, int height, int num) {   
        this.x = x;   
        this.y = y;   
        this.width = width;   
        this.height = height;   
        this.num = num;   
    }   
  
    /**  
     * 对图片裁剪，并把裁剪完的新图片保存  
     */  
    public void cut() throws IOException {   
  
        FileInputStream is = null;   
        ImageInputStream iis = null;   
  
        try {   
            // 读取图片文件   
            is = new FileInputStream(srcpath);   
  
            /**  
             * 返回包含所有当前已注册 ImageReader 的 Iterator，这些 ImageReader 声称能够解码指定格式。  
             * 参数：formatName - 包含非正式格式名称 . （例如 "jpeg" 或 "tiff"）等 。  
             */  
            Iterator<ImageReader> it = ImageIO   
                    .getImageReadersByFormatName("jpg");   
            ImageReader reader = it.next();   
            // 获取图片流   
            iis = ImageIO.createImageInputStream(is);   
  
            /**  
             * iis:读取源.true:只向前搜索.将它标记为 ‘只向前搜索’。 此设置意味着包含在输入源中的图像将只按顺序读取，可能允许  
             * reader 避免缓存包含与以前已经读取的图像关联的数据的那些输入部分。  
             */  
            reader.setInput(iis, true);   
  
            /**  
             * <p>  
             * 描述如何对流进行解码的类  
             * <p>  
             * .用于指定如何在输入时从 Java Image I/O 框架的上下文中的流转换一幅图像或一组图像。用于特定图像格式的插件 将从其  
             * ImageReader 实现的 getDefaultReadParam 方法中返回 ImageReadParam 的实例。  
             */  
            ImageReadParam param = reader.getDefaultReadParam();   
  
            /**  
             * 图片裁剪区域。Rectangle 指定了坐标空间中的一个区域，通过 Rectangle 对象  
             * 的左上顶点的坐标（x，y）、宽度和高度可以定义这个区域。  
             */  
            Rectangle rect = new Rectangle(x, y, width, height);   
  
            // 提供一个 BufferedImage，将其用作解码像素数据的目标。   
            param.setSourceRegion(rect);   
  
            /**  
             * 使用所提供的 ImageReadParam 读取通过索引 imageIndex 指定的对象，并将 它作为一个完整的  
             * BufferedImage 返回。  
             */  
            BufferedImage bi = reader.read(0, param);   
  
            // 保存新图片   
            ImageIO.write(bi, "jpg", new File(subpath + num + ".jpg"));   
        } finally {   
            if (is != null)   
                is.close();   
            if (iis != null)   
                iis.close();   
        }   
    }   
  
    public static void main(String[] args) throws IOException {   
        BufferedImage bufferedImage = ImageIO.read(new File(srcpath));         
        File file = new File(subpath); //创建切片存放的目录   
        file.mkdirs();   
           
        int init_width = bufferedImage.getWidth(); //获得原始图片的宽   
        int init_height = bufferedImage.getHeight(); //获得原始图片的高        
        int x = 0; //x坐标点   
        int y = 0; //y坐标点   
        int width = init_width / x_share; //裁切后图片的宽   
        int height = init_height / y_share; //裁切后图片的高   
        int sum = (init_width / width) * (init_height / height); //获得切片的总数   
  
        for (int i = 1; i <= sum; i++) {   
            if (x == init_width) {   
                x = 0;   
                y = y + height; //y坐标移动   
            }   
            CutImage ci = new CutImage(x, y, width, height, i);   
            x = x + width; //x坐标移动   
            try {   
                ci.cut();   
            } catch (IOException e) {   
                e.printStackTrace();   
            }   
        }   
  
        System.out.println("************THEEND************");   
    }   
}  
